<!DOCTYPE html>
<html lang="en">
<head>
        <meta charset="utf-8"/>
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta http-equiv="X-UA-Compatible" content="ie=edge">
        <title>Thoughts on Data Science, ML and Startups - Machine Learning Design Patterns: Data Representation</title>
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css"/>
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.2/css/all.min.css"/>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto+Slab|Ruda"/>
        <link rel="stylesheet" type="text/css" href="https://va1da2.github.io/theme/css/main.css"/>
            <link href="https://va1da2.github.io/
feeds/all.atom.xml"
                  type="application/atom+xml" rel="alternate" title="Thoughts on Data Science, ML and Startups Atom Feed"/>

<meta name="tags" content="machine learning" />
<meta name="tags" content="ml" />
<meta name="tags" content="data science" />
<meta name="tags" content="design patterns" />
</head>
<body>
<a href="https://github.com" class="github-corner" aria-label="View source on GitHub">
    <svg width="80" height="80" viewBox="0 0 250 250"
         style="fill:#8B8B7A; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
<style>.github-corner:hover .octo-arm {
    animation: octocat-wave 560ms ease-in-out
}
@keyframes octocat-wave {
    0%, 100% {
        transform: rotate(0)
    }
    20%, 60% {
        transform: rotate(-25deg)
    }
    40%, 80% {
        transform: rotate(10deg)
    }
}
@media (max-width: 500px) {
    .github-corner:hover .octo-arm {
        animation: none
    }

    .github-corner .octo-arm {
        animation: octocat-wave 560ms ease-in-out
    }
}</style><div id="container">
    <header>
        <h1><a href="https://va1da2.github.io/">Thoughts on Data Science, ML and Startups</a></h1>
            <ul class="social-media">
                    <li><a href="https://www.linkedin.com/in/vaidasarmonas/"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
                    <li><a href="https://github.com/Va1da2"><i class="fab fa-github fa-lg" aria-hidden="true"></i></a></li>
                    <li><a href="https://www.goodreads.com/vaidas_armonas"><i class="fab fa-goodreads fa-lg" aria-hidden="true"></i></a></li>
                    <li><a href="https://va1da2.github.io/
feeds/all.atom.xml"
                           type="application/atom+xml" rel="alternate"><i class="fa fa-rss fa-lg"
                                                                          aria-hidden="true"></i></a></li>
            </ul>
        <p><em></em></p>
    </header>
    <nav>
        <ul>
                    <li><a href="https://va1da2.github.io/category/book-reviews.html"> Book reviews </a></li>
                    <li><a                         class="active" href="https://va1da2.github.io/category/data-science.html"> Data Science </a></li>
                    <li><a href="https://va1da2.github.io/category/startups.html"> Startups </a></li>
                    <li><a href="https://va1da2.github.io/pages/about.html">About</a>
                    </li>
                    <li><a href="https://va1da2.github.io/pages/book-recommendations.html">Book recommendations</a>
                    </li>
        </ul>
    </nav>
<main>
    <article>
        <h1>Machine Learning Design Patterns: Data Representation</h1>
        
        <aside>
            <ul>
                <li>
                    <time datetime="2021-01-09 12:26:48+02:00">Jan 09, 2021</time>
                </li>
                <li>7 min read</li>
                <li>
                    Categories:
                    <a href="https://va1da2.github.io/category/data-science.html"><em>Data Science</em></a>
                </li>
                <li>
                    Tags:
                    <a href="https://va1da2.github.io/tag/machine-learning.html"><em>#machine learning</em></a>
                    <a href="https://va1da2.github.io/tag/ml.html"><em>#ml</em></a>
                    <a href="https://va1da2.github.io/tag/data-science.html"><em>#data science</em></a>
                    <a href="https://va1da2.github.io/tag/design-patterns.html"><em>#design patterns</em></a>
                </li>
            </ul>
        </aside>
        <p>Design patterns are a set of best practices and solutions to common problems. Machine learning engineers as engineers in other disciplines can benefit immensely by following such idioms. In this and following posts, I will discuss ML patterns outlined in <a href="https://www.amazon.co.uk/Machine-Learning-Design-Patterns-Preparation/dp/1098115783/ref=sr_1_1?crid=NI2IJ980L4YN&amp;dchild=1"><strong>Machine Learning Design Patterns by V. Lakshmanan, S. Robinson &amp; M. Munn</strong></a></p>
<h1>Data Representation Design Patterns</h1>
<p>Let us start with <strong>Data Representation Patterns</strong>. These patterns focus on the feature engineering part of the ML workflow. It would be a stretch to call some simple and commonly used techniques a <code>design pattern</code>:
1. Linear transformations: <strong>min-max scaling</strong>, <strong>clipping</strong>, and <strong>z-score normalization</strong>; 
2. Non-linear transformations: <strong>logarithms</strong>, <strong>taking a root of a value</strong>, <strong>histogram equalization</strong>, and <strong>box-cox transform</strong>; 
3. Categorical feature handling: <strong>one-hot-encoding</strong> (this might be a pattern, but it's just too common these days, and there are quite a few better approaches);
4. Handling array of categorical features: <strong>array statistics</strong>;</p>
<p>Patterns that authors describe in the book, and we will discuss here are: <strong>Embeddings</strong>, <strong>Feature Cross</strong>, <strong>Multimodal Input</strong>, and <strong>Hashed Feature</strong>, </p>
<h2>Embeddings</h2>
<p>An embedding is a learnable representation of a high cardinality feature into a lower-dimensional space while preserving information. I would even say that embeddings can enhance categorical features by encoding them to make ML tasks easier for a learning algorithm. These days (DL boom), it seems that everybody knows to use an image embedding in some ML task if an image is a contributing factor. However, this pattern is not only about this type of embedding. Let us see what problems this pattern address.</p>
<h3>Problem</h3>
<p>The problem with categorical features is that simple conversion techniques do not capture relationships between classes and rely on the algorithm to distill those relationships. Whatever categorical feature you have:
A day of the week - if day number starts from Sunday, Saturday and Sunday will be far apart in terms of numerical value, while they are most likely close to each other in meaning;
A book or a food category - we can one-hot encode them, but we cannot encode relationships among the classes this way;
Very high cardinality features, such as a fine-grained catalog of an e-shop, can be impractical one-hot encode.
All categorical features would benefit from embedding. The cardinality may also play a role here - if we have a vast vocabulary for categorical feature (fine-grained catalog in an e-shop can be prohibitively large to one-hot encode)</p>
<p>There is also a problem with unstructured data incorporation into our algorithm. Text, image, and audio are rich sources of information but are not easy to incorporate in algorithms that are not specifically built for those types of input.</p>
<h3>Solution</h3>
<p>Embeddings are a great way to encode categorical or unstructured data so that other algorithms can use a better representation of the feature.</p>
<p>Embedding categorical features is probably the best and easiest way to improve model performance. By learning an embedding for any categorical feature, we extract information on how categories relate to each other for the task we are trying to learn. Embedding boosts the algorithm's performance and has a nice side effect - we can use learned embeddings in different learning tasks.</p>
<p>Embedding unstructured data is almost the only way to include that data in learning models. Suppose we have a problem that would benefit from including unstructured information. In that case, we could use one of the pre-trained models for images (one of many trained on ImageNet) or text (e.g., Glove/Word2Vec word vectors) and include the provided information to any other model together with structured data.</p>
<h3>Discussion</h3>
<p>The embedding pattern is unique - there is no real alternative to it. We can encode categories by integers or one-hot encode them, but it is not even close in terms of model performance. If possible, we should always use <strong>Embedding pattern</strong>; the only consideration is about what type of embedding to include.</p>
<h2>Feature Cross</h2>
<p>Combining feature values and making every combination a different feature helps our algorithm learn relationships between characteristics faster.</p>
<h3>Problem</h3>
<p>When our features relate in non-linear ways, we can improve our model by providing those non-linear features by "crossing" them.</p>
<p>One typical example is a time of day and the day of the week for some event. For instance, we want to predict a demand for bikes in a specific city bike-sharing spot. Having just time of day and day of the week might not be enough, and an explicit <code>AND</code> relationship could improve our model.</p>
<h3>Solution</h3>
<p>Feature cross is a simple combination of two or more categorical features (or bucketed numerical ones). For example, if we have the day of a week (Monday, Tuesday, etc.) and the time of day (1 PM, 2 PM, etc.) features, we could get the time of the day of a week feature (Monday 1 PM, Monday 2 PM, Tuesday 1 PM, etc.). Crossing features increase cardinality considerably; therefore, using this pattern with the embedding pattern could yield even better results.</p>
<h3>Discussion</h3>
<p>Feature crosses are a simple way to introduce non-linearity in our models and help to learn relationships faster. This pattern is even better when using it with the embeddings pattern discussed above. However, we should consider features that we want to cross carefully. Since this pattern increases the model's complexity quite a bit, we should not go and cross all our features.</p>
<h2>Multimodal Input</h2>
<p>When we have multiple representations of the phenomenon that we want to model, we should include all those representations in our algorithm.</p>
<h3>Problem</h3>
<p>Many algorithms that are available online are designed for a specific type of input - image models (ResNets), text models (all the transformers out there), audio models (I haven't used any myself so far). However, there is a significant class of problems where we would like to use several types of inputs — a combination of structured and unstructured data. For example, modeling social media campaign results include all the above input types.</p>
<h3>Solution</h3>
<p>By employing the embedding pattern, we can join different types of input into a single model. We can either use any of the pre-trained models for image/text input and extract the last layer features to concatenate them with numerical or categorical features. For example, if we classify a complicated situation from a picture, having metadata about that situation (date and time, weather, geographical location, etc.) can significantly increase our model's accuracy.
Additionally, this pattern is useful with the same data but different representations - bucketing is the simplest example. For example, if we have a distance feature in a dataset as a continuous feature, bucketing could help us learn non-linear relationships. Maybe very short and very long distances correlate with our outcome.</p>
<h3>Discussion</h3>
<p>As data scientists/machine learning engineers, we should always seek new features to add to our models. By seeking out features from different modalities of the phenomenon, we can build better models. Similarly, we can increase our model's performance by presenting the same information from a different angle.</p>
<h2>Hashed Feature</h2>
<p>The hashed feature design pattern is an interesting approach meant to address cold start, incomplete vocabulary, and model size problems.</p>
<h3>Problem</h3>
<p>Having high cardinality categorical features poses three main challenges when building an ML model:
* Not all categories might exist in the training dataset;
* The number of categories might be prohibitively big;
* Cold-start problem;</p>
<h3>Solution</h3>
<p>The proposed solution is a deterministic hash function (authors of the book proposes <a href="https://github.com/google/farmhash"><code>FarmHash</code></a>). We would hash a given categorical feature in a pre-defined number of buckets and would use that as a feature instead of the original value. With this approach, we tick all the above boxes:
* All categories would get a bucket, even those that were not present in the training dataset;
* We control how many buckets we hash our values into;
* Even new values of the feature that wasn't available during training time would get handled (our model would not error out.)</p>
<h3>Discussion</h3>
<p>This pattern is the least appealing of all the data representation design patterns. There might be situations where this is necessary, but it should be a necessity. By randomly assigning buckets to our feature values, we might group very different values, and therefore our model would suffer. So I would go with anything other than hashing, if possible, describing high cardinality features with values metadata or descriptive statistics. Maybe grouping those values based on those statistics and then using that as an input for future values to handle the cold start problem.</p>
<p>On the other hand, this is the only new design pattern, so I am delighted that the authors decided to include this.</p>
<h2>Conclusion</h2>
<p>This post is the first in the series about ML design patterns. The book contains several more chapters I intend to write about, including <strong>Problem Representation Design Pattern</strong>, <strong>Model Training Patterns</strong>, <strong>Model Serving Design Patterns</strong>, <strong>Reproducibility Design Patterns</strong>, and <strong>Responsible AI Design Patterns</strong>.</p>
<h3>Other Posts in Machine Learning Design Patterns Series</h3>
<ul>
<li><a href="/machine-learning-design-patterns-problem-representation-part-1.html">Problem Representation Design Patterns Part 1</a></li>
<li><a href="/machine-learning-design-patterns-problem-representation-part-2.html">Problem Representation Design Patterns Part 2</a></li>
</ul>
    </article>
    <section class="post-nav">
        <div id="left-page">
            <div id="left-link">
                <div id="left-arrow"><i class="fa fa-chevron-circle-left"></i></div>
                <a href="https://va1da2.github.io/machine-learning-design-patterns-problem-representation-part-1.html"> Machine Learning Design Patterns: Problem Representation Part 1</a>
            </div>
        </div>
        <div id="right-page">
            <div id="right-link">
                <a href="https://va1da2.github.io/2020-in-books.html">2020 in Books </a>
                <div id="right-arrow"><i class="fa fa-chevron-circle-right"></i></div>
            </div>
        </div>
    </section>
    <div>
    </div>
</main>
    <footer>
        <h6>
            Rendered by <a href="http://getpelican.com/">Pelican</a> &nbsp;&bull;&nbsp; Theme by <a
                href="https://github.com/aleylara/Peli-Kiera">Peli-Kiera</a> &nbsp;&bull;&nbsp; Copyright
                &copy2021  &nbsp;&#8209;&nbsp; Vaidas Armonas         </h6>
    </footer>
</div>
    <script type="text/javascript">
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-187862762-1', 'auto');
    ga('send', 'pageview');
    </script>
</body>
</html>
